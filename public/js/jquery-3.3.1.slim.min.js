/ *! jQuery v3.3.1 -ajax, -ajax /
jsonp, -ajax / yük, -ajax / parseXML, -ajax / komut
dosyası, -ajax /
var / konum, -ajax /
var / nonce, -ajax /
var / rquery, -Jaax /
xhr, -manipulation / _evalUrl, -event / ajax, efektler, efektler / Tween, efektler / hareketliSelektör | (c)
JS
Vakfı
ve
diğer
katılımcılar | jquery.org / license * /
fonksiyonu(e, t)
{
  "use strict";
  "object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : işlev(e) {if(
  !e.document
)
  yeni
  Hata
  attı("jQuery bir belgeyle bir pencere gerektirir");
  t(e)
}
  i
  döndürme: t(e)
}
("undefined"
! = typeof window ? window : this, function (e, t) {
  "use strict";
  var n = [], r = e.document, i = Object.getPrototypeOf, o = n.slice, a = n.concat, u = n.push, s = n.indexOf, l = {},
    c = l.toString, f = l.hasOwnProperty, d = f.toString, p = d.call(Nesne), h = {}, g = işlev
  e(t)
  {
    dönüş
    "işlevi " == typeof t && " number "
    ! = typeof t.nodeType
  }
,
  v = işlev
  e(t)
  {
    return null
    ! = t && t === t.window
  }
,
  y = {type: !0, src: !0, noModule: !0};
  işlev
  m(e, t, n)
  {
    var i, o = (t = t || r).createElement("script");
    eğer(o.text = e, n)
    için(i
    y
  )
    n [i] && (o [i] = n [i])
    t.head.appendChild(o).parentNode.removeChild(o)
  }
  işlev
  b(e)
  {
    return null == e ? e + "" : "object" == typeof e || "işlev" == typeof e ? l [c.call(e)] || " nesne " : typeof e
    " var x = "
    3.3
    .1 - Jaax, -Jaax / jsonp, -Jaax / yük, -Jaax / parseXML, -Jaax / komut
    dosyası, -Jaax /
    var / konum, -Jaax /
    var / nonce, -ajax /
    var / rquery, -ajax /
    xhr, -manipülasyon / _evalUrl, -event / ajax, efektler, efektler / Tween, -effects / animatedSelector
    ", w = fonksiyon (e, t) {return new w.fn .init (yani, t)}, C = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g w.fn = w.prototype = {jQuery: x, yapıcı : w, uzunluk: 0, toArray: function () {return o.call (this)}, get: function (e) {return null == e? o.call (this): e <0? bu [e + this.length]: this [e]}, pushStack: function (e) {var t = w.merge (this.constructor (), e); t.prevObject = this, t}, herbirini döndürür: function (e) {dönüş w.each (bu, e)}, harita: işlev (e) {return this.pushStack (w.map (bu, işlev (t, n) {return e.call (t, n, t)}) )},slice: function () {return this.pushStack (o.apply (this, arguments)), önce: function () {return this.eq (0)}, son: function () {return this.eq (-1) )}, eq: function (e) {var t = this.length, n = + e + (e <0? t: 0); this.pushStack döndürün (n> = 0 && n <t? [this [n]]: [])}, end: function () {return this.prevObject || this.constructor ()}, itme: u, sırala: n.sort, ekleme: n.splice}, w.extend = w.fn.extend = function () {var e, t, n, r, i, o, a = argümanlar [0] || {}, u = 1, s = arguments.length, l =! 1; for ("
    boolean
    " =) = a && (l = a, a = arguments [u] || {}, u ++), "
    object
    " == türkçe a. g (a) || (a = {}), u === s && = a = bu, u -); u <s; u ++) eğer (null! = (e = arguments [u])) için (t in e) n = a [t], a! == (r = e [t]) && (l && r && (w.isPlainObject (r) || (i = Array.isArray (r))) (i (i = 1, n = && Array.isArray (n) terimi n: o?!? [] ): o = n && w.isPlainObject (n)? n: {}, a [t] = w.extend (l, o, r)): void 0! == r && (a [t] = r));a}, w.extend ({expando: "
    jQuery
    " + (x + Math.random ()). değiştir (/ \ D / g, "
    "), isReady:! 0, hata: function (e) {throw yeni Hata (e)}, noop: function () {}, isPlainObject: function (e) {var t, n; dönüş! (! e || "[object
    Object
  ]
    "! == c.call (e)) && (! (t = i (e)) || "
    işlev
    " == typeof (n = f.call (t, "
    yapıcı
    ") && t.constructor) && n d.call () === s)}, isEmptyObject : işlev (e) {var t; (t in e için) geri dönüş! 1; dönüş! 0}, globalEval: function (e) {m (e)}, her biri: function (e, t) {var n, r = 0; eğer (T (e)) {(n = e.length, r <n, r ++), (! 1 === t.call (e [d], r, e [d])) halinde ara } else (r in e) için eğer (! 1 === t.call (e [r], r, e [r])) koparsa, geri dönün e}, trim: function (e) {return null == e ? "
    " :( e + "
    "). değiştirin (C, "
    ")}, makeArray: function (e, t) {var n = t || []; dönüş null! = e && (T (Object (e)) w.merge (n, "
    string
    " == typeof e? [e]: e): u.call (n, e)), n},inArray: function (e, t, n) {return null == t? -1: s.call (t, e, n)}, birleştirme: function (e, t) {for (var n = + t.length) , r = 0, i = e.length; r <n; r ++) e [i ++] = t [r]; dönüş e.length = i, e}, grep: function (e, t, n) {for ( var r, i = [], o = 0, a = e.length, u =! n; o <a; o ++) (r =! t (e [o], o))! == u && i.push ( e [o]), i} i, map: function (e, t, n) {var r, i, o = 0, u = []; if (T (e)) için (r = e.length; o <r; o ++) null! = (i = t (e [o], o, n)) & \ u.push (i); (o, e için) null! = (i = t (e [o] için) , o, n)) && u.push (i); a.apply ([], u)}, guid: 1, destek: h}), "

    function

    " == typeof Symbol && (w.fn [Symbol.iterator] döndür ] = n [Symbol.iterator]), w.each ("
    Boolean
    Number
    String
    İşlev
    Dizisi
    Tarihi
    RegExp
    Object
    Error
    Symbol
    " .split ("
    "), function (e, t) {l ["[object
    " + t + "
  ]]
    "] = t.toLowerCase ()}); fonksiyon T (e) {var t = !! e &&"
    uzunluk
    ", e && e.length, n = b (e); return! g (e) &&!v (e) && ("
    dizi
    " === n || 0 === t || "
    sayı
    " == t && t> türünde 0 && t-1 e)} var E = işlev (e) {var t, n, r, i, l, c, f, d, p, h, g, v, y, m, b, x = "
    sizzle
    " + 1 * yeni Tarih, w = e.document , C = 0, T = 0, E = ae (), N = ae (), k = ae (), A = fonksiyon (e, t) {return e === t && (f =! 0), 0 }, D = {}. hasOwnProperty, S = [], L = S.pop, j = S.push, q = S.push, O = S.slice, p = fonksiyonu (yani, t) {için (var n = 0, r = e.length; n <r; n ++) eğer (e [n] === t) return n; return-1}, H = "
    checked | selected | async | autofocus | autoplay | controls | erteleme | devre
    dışı | gizli | ismap | döngü | birden | açık | salt
    okunur | gerekli | kapsama
    "J = "[\\ x20 \\ t \\ r \\ n \\ f
  ]
    ", R '="(
  : \ . \\\ |
    [\\ w
  ] |
    [ ^ \ 0 - \\ xa0
  ])
    +"B = "\\ [" + I " * (" + R ")(? : " + I" * ([! * ^ $ | ~] = ?) "+ I +" * (? : '((:?. \\\\ | [^ \\\\']
  ) *)
    '| \ "((?: \\\\ |. [^ \\\\\ "]) *) \" | ( "+ R")) |) "+ I"* \\]", E = ":(" + R ") (: \\ (((? '((
  :. \\\\ |
    [ ^ \\\\']) *) ' | \" ((:?. \\\\ | [^ \\\\\ "
  ]) *) \") | ((:?. \\\\ | [^ \\\\ () [\\]] | " + B + ") *) |. *) \\) |) ", W = yeni
    RegExp(I + " + ", " g "), $ = yeni
    RegExp(" ^ " + I + " + | ((?:) ^ | [^ \\\\]) (?: \\\\.) *) " + I + " + $ ", " g "), F = yeni
    RegExp(" ^ " + I + " *, " + I + "*"), z = yeni
    RegExp("^" + I + "* ([> + ~] |" + I + ")" + I + "*"), _ = yeni
    RegExp("=" + I + "* ( [^ \\] '\ "
  ] *
      ?
  )
    " + I + " * \\]
    ", "
    g
    "), U = yeni RegExp (M), V = yeni RegExp (" ^ " + R + "
    $
    "), X = {ID: new RegExp (" ^ #(" + R + ")
    "), SINIF: yeni RegExp (" ^ \\.
    (" + R + ")
    "), TAG: yeni RegExp (" ^ (" + R +) " | [ *
  ])
    "), ATTR: yeni RegExp (" ^ " + B), PSEUDO: yeni RegExp (" ^ " + M), ÇOCUK:Yeni RegExp (" ^
  :
    (sadece | ilk | son | nth | nt - son) - (alt - tür)(? : \\ (" + I + " * (çift | tek | (([+-] |)(\\ d *
  )
    n |
  )
    "+ I +" * (? : ([+-] |)
    "+ I +" * (\\ d +
  ) |))
    "+ I +" * \\) |)
    ", "
    i
    "), bool: yeni RegExp (" ^ (? : " + H + ")
    $
    ", "
    i
    "), needsContext: yeni RegExp (" ^ " + I + " * [ > +~
  ] |:
    (hatta | tek | eşdeğer | gt | lt | ilk | | inci)
    son(
  :
      ? \\ ("+ I" * ((
  :
    - \\ d
  ) \\ d *
  )
    "+ I" * \\) |)
    (= [ ^ -
  ] |
      ? $
  )
    ", "
    i
    ")}, Q = / ^ (?: giriş | seçme | metinalanı | düğmesi) $ / i, Y = / ^ s \ d $ / i, G = / ^ [^ {] + \ {\ s * \ [native \ w /, K = / ^ (?: # ([\ w -] +) | (\ w +) | \. ([\ w -] + )) $ /, J = / [+ ~] /, Z = yeni RegExp ("\\\\ ([\\ da - f
  ]
    {
      1, 6
    }
    " + I + " ?
  |
    (" + I + ") |
  .)
    ","
    ig
    "), ee = işlev (e, t, n) {var r ="
    0
    x
    "+ t-65536; dönüş r! == r || n? t: r <0? String.fromCharCode (r + 65536): String.fromCharCode (r >> 10 | 55296,1023 ve r | 56320)},te = / ([\ 0- \ x1f \ x7f] | ^ - \ D?) | ^ - $ | [^ \ 0- \ \ w x7f- \ UFFFF \ x1f -] / g, ne = fonksiyonu (e, t) {return t? "\ 0
    " === e? "\ ufffd
    ": e.slice (0, -1) + "\\" + e.charCodeAt (e.length-1) .toString (16) + "
    ": "\\" + e}, re = function () {d ()}, yani = me (işlev (e) {return! 0 === e.disabled && ("
    form
    " in e || "
    etiketi
    "e"
  ), {dir: "parentNode", sonraki: "legend"}
)
;
{
  q.apply(S = O.call(w.childNodes), w.childNodes), S [w.childNodes.length].nodeType
}
yakala(e)
{
  q = {Uygula: S.boy = işlev(e, t)
  {
    j.apply(e, O.call(t))
  }
:
  işlev(e, t)
  {
    var =
    e.length, r = 0;
    iken(e [n++] = t [r++]);
    e.length = n - 1
  }
}
}
işlev
oe(e, t, r, i)
{
  var o, u, l, c, f, h, y, m = t && t.ownerDocument, C = t ? t.nodeTip : 9;
  if (r = r || [], "string"! = typeof e || !e || 1
  ! == C && 9
  ! == C && 11
  ! == C
)
  dönüş
  r;
  if (!İ && ((t ? T.ownerDocument || t : w)! == p && d(t), t = t || p, g
))
  {
    (11
    eğer !== C && (f = K.exec(e))
  )
    if (o = f [1]) {
      if (9 === C) {
        if (!(L ​​= t.getElementById(o)
      ))
        geri
        dönüş
        r;
        if (l.id == o o
      )
        döndürme
        r.push(l), r
      } else ise(m && (l = m.getElementById(o)) && b(t, l) && l.id === o)
      dönüş
      r.push(l), r
    } else {
      if (f [2]) döndürür
      q.apply(r, t.getElementsByTagName(e)), r;
      if ((o = f [3]) && n.getElementsByClassName && t.getElementsByClassName) return q.apply(r, t.getElementsByClassName(o)), r
    }
    if (n.qsa && !k [e + ""] && (!v || !v.test(e))) {
      if (1! = = C
    )
      m = t, y = e;
    else
      ise("object"
      ! == t.nodeName.toLowerCase()
    )
      {
        (c = t.getAttribute("id")) ? C = c.replace(te, ne) : t.setAttribute("id", c = x), u = (h = a(e)).ken;
        (u -)
        h [u] = "#" + c + "" + ye(h [u])
        y = h.join(","), m = J.test(e) && ge(t.parentdeğer) || t
      }
      if (y) deneyin
      {
        return q.apply(r, m.querySelectorAll(y)), r
      }
      yakalamak(e)
      {
      }
      son
      {
        c === x && t.removeAttribute("id")
      }
    }
  }
  döndürün(e.replace($, "$ 1"), t, r, i)
}

function ae() {
  var e = [];
  işlev
  t(n, i)
  {
    dönüş
    e.push(n + "") > r.cacheLength && delete t [e.shift()], t [n + ""] = i
  }
  geri
  dönme
  işlevi
  ue(e)
  {
    return e [x] = !0, e
  }
  işlev
  se(e)
  {
    var t = p.createElement("fieldset");
    {
      return !!e(t)
    }
  catch
    (e)
    {
      return !1
    }
    sonunda
    {
      t.parentNode && t.parentNode.removeChild(t)
      öğesini
      deneyin.t = null
    }
  }
  le(e, t)
  fonksiyonu
  {
    var n = e.split("|"), i = n.length;
    (i -)
    r.attrHandle [n [i]] = t
  }
  işlevi
  ce(e, t)
  {
    var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex;
    eğer(r)
    dönüş
    r;
    if (n) while (n = n ise
  ) .
    nextSibling
  )

(n === t)
return -1
ise,
return e ? 1 : -1
}

function fe(e) {
  return işlevi(t)
  {
    return "girişi" === t.nodeName.toLowerCase() &&
  .
    type === e
  }
}

işlev
de(e)
{
  dönüş
  işlevi(t)
  {
    var n = t.nodeName.toLowerCase();
    dönüş("giriş" === n || "düğmesi" === n) && t.type === e
  }
}
işlev
pe(e)
{
  dönüş
  işlevi(t)
  {
    return "formu" in t
    t.parentNode && !1 === t.disabled ? t.parentNode ? t.parentNode.disabled = "t" etiketinde "etiket"
    e = t.disabled === e
  :
    t.isDisabled == = e || t.isDisabled
    ! == !e && yani(t) === e
  :
    t.disabled === e
  :
    t && t.disabled === e
  }
  içindeki
  "label"
}
fonksiyonu
o(e)
{
  return ue(işlev(t)
  {
    dönüş
    t = +t, ue(işlev(n, r)
    {
      var i, o = e([], n.length, t), a = o.length;
      (a -)
      n
      iken [i = o [a]] && (n [i] = !(r [i] = n [i]))
    }
  )
  }
)
}
işlevi
ge(e)
{
  return e && "undefined"
  ! = türetilmiş
  e.getElementsByTagName && e
}
n = oe.support = {}, o = oe.isXML = işlev(e)
{
  var t = e && (e.ownerDocument || e).documentElement;
  return !!t && "HTML"
  ! == t.nodeName
}
,
d = oe.setDocument = function (e) {
  var t, i, a = e ? e.ownerDocument || e : w;
  a
  ! == p && 9 === a.nodeType && a.documentElement ? (p = a, h = p.documentElement, g = !o(p), w! == p && (i = p.defaultView) && itop
  ! == i && (i.addEventListener ? i.addEventListener("boşaltma", yeniden!)
  1
):
  i.attachEvent && i.attachEvent("kendload", re)
),
  n.attributes = se(işlev(e)
  {
    return e.className = "i", !e.getAttribute("className")
  }
),
  n.getElementsByTagName = se(işlev(e)
  {
    return e.appendChild(p.createComment("")) , !e.getElementsByTagName("* ").length
  }
),
  n.getElementsByClassName = G.test(p.getElementsByClassName), n.getById = se(işlev(e)
  {
    return h.appendChild(e).id = x, !p.getElementsByName || !p.getElementsByName(x).length
  }
),
  n.getById ? (r.filter.ID = işlev(e) {var t = e.replace(Z, ee);
  dönüş
  işlevi(e)
  {
    return e.getAttribute("kimlik") === t
  }
}
  r.find.ID = fonksiyonu(yani, t)
  {
    (eğer
    "undefined "
    ! = typeof t.getElementById && g
  )
    {
      var n = t.getElementById(e);
      return n ? [n] : []
    }
  }
) :
  (r.filter.ID = işlev(e)
  {
    var t = e.değiştir(Z, ee);
    dönüş
    işlevi(e)
    {
      var n = "undefined"
      ! = typeof e.getAttributeNode && e.getAttributeNode("id");
      return n && n.value === t
    }
  }
,
  r.find.ID = function (e, t) {
    if ("undefined"! = tt_getElementById && g
  )
    {
      var n, r, i, o = t.getElementById(e);
      if (o) {
        if ((n = o.getAttributeNode) "kimlik"
      )) && n.value === e
)
geri [o];
i = t.getElementsByName(e)
r = 0;
iken(o = i [r++])
halinde((n = o.getAttributeNode(" id ")) && n.value === e)
geri
dönüş [o]
}
return []
}
}),
r.find.TAG = n.getElementsByTagName ? function (e, t) {
  return " undefined "
  ! = typeof t.getElementsByTagName ? t.getElementsByTagName(e) : n.qsa ? t.querySelectorAll(e) : void 0
} : işlev(e, t)
{
  var n, r = [], i = 0, o = t.getElementsByTagName(e);
  Eğer("* " === e)
  {
    while (n = o [i++]) 1 === n.nodeTip && r.push(n);
    dönüş
    r
  }
  dönüşü
  o
}
,
r.find.CLASS = n.getElementsByClassName && function (e, t) {
  if ("undefined"! = typeof t.getElementsByClassName && g
)
  t.getElementsByClassName(e)
}
değerini
döndür, y = [], v = [], (n.qsa = G.test(p.querySelectorAll)) && (se(işlev(e)
{
  h.appendChild(e).innerHTML = "<a id='" + x + "'> </a> <select id = '" + x + "- \ r \\' msallowcapture = '' > <option selected = ''> </ option> </ select> ", e.querySelectorAll(" [msallowcapture ^ = ''] ").uzunluk && v.push(" [* ^ $] = " + I + " * ( : '' | \ "\") "
),
  e.querySelectorAll(" [seçilen] ").uzunluğu || v.push(" \\ [ " + I
  " * (?: değeri | " + H
  "), "
),
  e.querySelectorAll(" [kimlik ~ = " + x + "-] ").Uzunluğu || v.push(" ~ = "), e.querySelectorAll(": "()
  uzunluğu || v.push
  " kontrol: kontrol "
),
  e.querySelectorAll(" a # " + x + "+ *").uzunluk || v.push(". #. + [+ ~]")
}
),
se(işlev(e)
{
  e.innerHTML = "<a href = '' disabled = 'disabled' > </a> <select disabled = 'disabled'> <option /> </ select> ";
  var t = p.createElement(" input ");
  t.setAttribute(" type ", " hidden "), e..appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name = d]")
  uzunluk && v.push("name" + I + "*? [* ^ $ |! ~] = "), 2 == e.querySelectorAll(!": "( &&)
  v.push
  uzunluğu
  " etkin: etkin", ":!!)"
  özürlü, h.appendChild(e) = 0, 2 == e.disabled.querySelectorAll(": devre dışı").uzunluğu && s.itme(": etkin", ": devre dışı"), e.querySelectorAll("* ,: X"), v.push("*.")
}
)),
(n.matchesSelector = G.test(m, = h.matches || h.webkitMatchesSelector || h.mozMatchesSelector || h.oMatchesSelector || h.msMatchesSelector)) && se(fonksiyonu(e)
{
  n.disconnectedMatch = m.call(yani, "*"), m.çağrı(e, "[s! = '']: x"), y.push("! =", M)
}
),
v = v.length && yeni
RegExp(v.join("|")), y = y.length && new RegExp(y.join("|")), t = G.test(h.compareDocumentPosition), b = t || G.test(h.contains) ? işlevi(e, t) {
  var n = 9 === e.nodeType ? E.documentElement : e,
  r = t && t.parentNode;
return e === r || !(!R || 1
! == r.nodeType || !(N.contains ? N.Contains(r) : e.compareDocumentPosition && 16
ve
e.compareDocumentPosition(r)
))
}:
!fonksiyonu(yani, t);
{
  halinde(±)
  ise(t = t.parentNode)
  halinde(t === e)
  geri
  0;
  dönüş
  !1
}
,
A = t ? fonksiyonu(yani, t) {if(e === t
)
döndürme
f = !0, 0;
var r = !e.compareDocumentPosition - !t.compareDocumentPosition;
return r || (1 & (r = (e.ownerDocument || e) = ? == (t.ownerDocument || t)
e.compareDocumentPosition(t)
:
1
) ||
n.sortDetached && t.compareDocumentPosition(e) === r
e === s || e.ownerDocument === ağırlık && b ? (e, a) - 1 : ? t === s || t.ownerDocument === (t, w, 1) && w b
:
c, p(c, e) - P(c, t)
:
0
:
4 - r ? -1 : 1
)
}:
işlev(e, t)
{
  if (e === t) döndürme
  f = !0, 0;
  var n, r = 0, i = e.parentNode, o = t.parentNode, a = [e], u = [t];
  eğer(!i || !o)
  döndürse
  e === p ? -1 : t === p ? 1 : i ? -1 : o ? 1 : c ? P(c, e) - P(c, t) : 0;
  eğer(i == o)
  dönüş
  ce(e, t);
  n = e;
  iken(n = n.parentNode)
  a.unshift(n)
  n = t;
  while (n = n.parentNode) u.unshift(n);
  (a [r] === u [r])
  r++
  iken, r = ce(a [r], u [r])
:
  a [r] === w ? -1 : u [r] === w ? 1 : 0
}
,
p
):
p
},
oe.delikler = fonksiyon(e, t)
{
  return oe(e, Null, boş, t)
}
,
oe.matchesSelector = fonksiyonu(yani, t);
{
  if ((e.ownerDocument || e)! == s && d(e), t = t.replace(_, "= '$ 1' ] "), n.matchesSelector && g && !k [t + ""] && (!y || !y.test(t)) && (!v || !v.test(t))
)
  deneyin
  {
    var r = m.call(e, t);
    if (r || n.disconnectedMatch || e.document && 11! == e.document.nodeType
  )
    döndürme
    r
  }
catch
  (e)
  {
  }
  return oe(t, p, null, [e]).
  0
}
,
oe.contains = fonksiyonu(yani, t);
{
  dönüş(e.ownerDocument || e)
  ! == s && d(e), b(e, t)
}
,
oe.attr = fonksiyonu(yani, t)
{
  (e.ownerDocument || e)
  ! == p && d(e);
  var i = r.attrHandle [t.toLowerCase()], o = i && D.call(r.attrHandle, t.toLowerCase()) ? i(e, t, !g) : void 0;
  dönüş
  geçersiz
  0
  ! == o ? o : n.attributes || !g ? e.getAttribute(t) : (o = e.getAttributeNode(t)) && o.specified ? o.value : null
}
,
oe.escape = işlev(e)
{
  return (e + "").replace(te, ne)
}
,
oe.error = işlev(e)
{
  throw new Error("Sözdizimi hatası, tanınmayan ifade: " + e)
}
,
oe.uniqueSort = işlev(e)
{
  var t, r = [], i = 0, o = 0;
  eğer(f = !n.detectDuplicates, c = !n.sortStable && e.slice(0), e.sort(A), f)
  {
    süre(t = E [o++])
    t === E [o] && (i = r.push(o));
    (iken
    i - -
  )
    e.splice(r [i], 1)
  }
  dönüş
  c = boş, e
}
,
i = oe.getText = işlev(e)
{
  var t, n = "", r = 0, o = e.nodeType
  eğer(o)
  {
    if (1 === o || 9 === o || 11 === o) {
      if ("string" == typeof e.textContent) e.textContent;
      e.firstChild;
      e;
      e = e.nextSibling
    )
n + = i(e)
} else
ise(3 === o || 4 === o)
e.nodeValue
}
değerini
döndürürken(t = e [r++])
n + = i(t);
dönüş
n
},
(r = oe.selectors = {
  cacheLength: 50,
  createPseudo: ue,
  eşleşme: X,
  attrHandle: {},
  bul: {},
  göreceli: {
    ">": {dir: "parentNode", önce: !0},
    "": {dir: "parentNode"},
    "+": {dir: "previousSibling", önce: !0},
    "~": {dir: "previousSibling"}
  },
  preFilter: {
    ATTR: function (e) {
      return e [1] = e [1].sayı(Z, ee), e [3] = (e [3] || e [4] || e [5] || "").Z, ee()
      yerine, "~ =" === e [2] && (e [3] = "" + e [3] + ""), e.slice(0, 4)
    }, ÇOCUK: işlevi(e)
{
  return e [1] = e [1].toLowerCase(), "inci" === e [1].slice(0, 3) ? (e [3] || oe.error(e [0]), e [4] = +(e [4] ? e [5] + (e [6] || 1) : 2( * "çift" === e [3] || "tek" === e [3])) e [5] = +(e [7] + e [8] || "tek" === e [3])
):
  e [3] && oe.error(e [0]), e
}
,
PSEUDO: işlev(e)
{
  var t, n = !e [6] && e [2];
  X.CHILD.test(e [0])
  'i döndürme: null: (e [3]? e [2] = e [4] || e [5] || "" n && U.test (n) && && (t = n.indexOf ( ""), n.length-t) -n.length) && (e [0] = e (t bir (n, 0) =!) [0] .slice (0, t), e [2] = n.slice (0, t)), e.slice (0,3))}}, filtre: {TAG: fonksiyon (e) {var t = e.replace (Z, ee) .toLowerCase (); "*" döndürür === e? function () {dönüş! 0}: işlev (e) {return e.nodeName && e.nodeName.toLowerCase () === t}}, CLASS: function (e) {var t = E [e + ""], döndürme t || (t = yeni RegExp ("(^ |" + I + ")"+ e +" ("+ I +" | $) ")) && E (e, işlev (e) {return t.test (" string "== typeof e.className && e.className ||" undefined "! = typeof e .getAttribute && e.getAttribute ("class") || "")})}, ATTR: function (e, t, n) {return işlevi (r) {var i = oe.attr (r, e); dönüş null = = i === t? "=":!? = "=== i t == n: t || (i + = "", "="? === i === n t"! ?: "^ =" === t n && 0 === i.indexOf (n): "* =" === t n && i.indexOf (n)> - 1: "$ =" === t n && i? .slice (-n.length) === n: "~ =" === t? ("" + i.replace (W, "") + ""). indexxf (n)> - 1: "| = "=== t && (i === n || i.slice (0, n.length + 1) === n +" - "))}} ÇOCUK: fonksiyonu (e, t, n, r, i) {var o = "nth"! == e.slice (0,3), a = "son"! == e.slice (-4), u = "of-type" === t;return 1 === r && 0 === i? işlevi (e) {return !! e.parentNode}: işlev (t, n, s) {var l, c, f, d, p, h, g = o! ?! == bir "nextSibling": "previousSibling", v = t.parentNode y u = && t.nodeName.toLowerCase (), m = && s u, b = 1, eğer (v) {(o) {! (g) {d = t etmektedir; ise (X = D [g]) (u d.nodeName.toLowerCase () === y: 1 === d.nodeType) ise! geri 1, h = g = "sadece" === e && h && "nextSibling"} geri 0} (h = [a v.firstChild: v.lastChild], bir && m)! {b = (p = (l = (c = (f = (d = h) [x] || (d [x] ' = {}
)
)
[d.uniqueID] || (f [d.uniqueID] = {})
)
[e] || []
)
[0] === Cı && l [1]
) &&
l [2]
d = p && v.childNodes [p];
sırasında || h.pop()(= p = 0
olduğu
B, D = ++p && d && d [g] || ()
)
halinde(1 === d.nodeType && ++b && d === t)
{
  c [e] = [C, p, b];
  break
}
}
başkaysa(m && (b = p = (l = (c = (f) = (x = t) [x] || (d [x]
'= {})) [d.uniqueID] || (f [d.uniqueID] = {})) [e] || []) [0 ] === Cı && l [1]) ,! 1 === b) (d = ++ p ise &&|| h.pop ()) ise (? (U d.nodeName.toLowerCase () === y: 1 === d.nodeType) (= p = 0 b) D && d [g] || && ++ b && (m && ((C = (f = ç [x] ' || (d [x]
' = {})) [d.uniqueID] || (f [d.uniqueID] = {})) [e] = [Cı b]), d === t)) kırmak; dönüş (b = l) === r || b% r == 0 && b / r> = 0}}} yalancı: fonksiyonu (yani, t); {var n, i = r.pseudos [e] || r.setFilters [e.toLowerCase ()] || oe.error ("desteklenmeyen yalancı:" + e); i [x]? i i (t): i.length> 1? (n = [e, e, "", t], r.setFilters.hasOwnProperty (e.toLowerCase ())? ue (işlev (e, n) {var r, o = i (e , t), a = o.length; ise, (a -) e = (n [r] o = [a])}) [r = P (örn, [a] o)]: fonksiyonu (e) {return i (e, 0, n)}): i}}, pseudos: {not: ue (işlev (e) {var t = [], n = [], r = u (e.replace ($, "$ 1")); r [x] '
ue(işlev(e, t, n, i)
{
  var o, a = r(e, null, i, []), u = e.leng;
  u -
)
(o = a [u]) && (e [u] = !(t [u] = o))
}):
işlev(e, i, o)
{
  dönüş
  t [0] = e, r
  !(t, sıfır, o, n)
  t [0] = sıfır, n.pop()
}
}),
varue(işlev(e)
{
  return işlevi(t)
  {
    return oe(e, t).length > 0
  }
}
),
şunları
içerir: ue(function (e) {
  return e = e.replace(Z, ee), işlev(t)
  {
    dönüş(t.textContent || t.innerText || i(t)).indexOf(e) > -1
  }
}), lang
:
ue(işlev(e)
{
  return V.test(e || "") || oe.error("desteklenmeyen lang:" + e), e = e.replace(Z, ee).toLowerCase(), function (t) {
    var n;
    do {
      if (n = g ? t.lang : t.getAttribute("xML: lang") || t.getAttribute("lang")) dönüş(n = n.toLowerCase()) === e || 0 === n.indexOf(e + " - ")
    } while ((t = t.parentNode) && 1 === t.nodeTip);
    dönüş
    !1
  }
}
),
hedef: işlev(t)
{
  var n = e.location && e.location.hash;
  dönüş
  n && n.dilimi(1) === t.id
}
,
kök: function (e) {
  return e === s
}
,
odaklama: function (e) {
  return e === p.activeElement && (!p.hasFocus || p.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)
}
,
etkin: pe(1), özürlü
:
!pe(0), kontrol
:

function (e) {
  var t = e.nodeName.toLowerCase();
  "input"
  değerini
  döndürür === t && !!e.checked || "option" === t && !!e.selected
}

,
selected: function (e) {
  return e.parentNode && e.parentNode.selectedIndex
  !0 === e.selected
}
boş:!{için fonksiyon(e)(e = e.firstChild, e, e = e.nextSibling) halinde(e.nodeType < 6
)
1
dönmek;
dönüş
0
} ,
parent: function (e) {
  return !r.pseudos.empty(e)
}
,
başlık: function (e) {
  return Y.test(e.nodeName)
}
,
giriş: function (e) {
  return Q.test(e.nodeName)
}
,
button: function (e) {
  var t = e.nodeName.toLowerCase();
  "input"
  değerini
  döndürür === t && "button" === e.type || "button" === t
}
,
text: function (e) {
  var t;
  return "girişi" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type"))) || "metin" === t.toLowerCase()
)
},
ilk: o(fonksiyonu()
{
  [0]
}
),
son
geri: o(fonksiyonunu(yani, t)
{
  geri [f - 1]
}
),
eq:o(işlev(e, t, n)
{
  dönüş [n < 0 ? n + t : n]
}
),
hatta: o(işlev(e, t)
{
  for (var n = 0; n < t; n + = 2) e.push(n);
  dönüş
  e
}
),
tek: o(fonksiyon(e, t)
{
  for (var n = 1; n < t; n + = 2) e.push(n);
  dönüş
  e
}
),
lt: o(işlev(e, t, n)
{
  for (var r = n < 0 ? n + t : n; -r > = 0;) e.push(r);
  dönüş
  e
}
),
gt: o(işlev(e, t, n)
{
  için(
  var r = n < 0 ? n + t : n;
  ++r < t;
)
  e.push(r);
  dönüş
  e
}
)
}
}).
pseudos.nth = r.pseudos.eq;
for (t {
  radyo:!0, onay
  kutusu:!0, dosya
:
  !0, şifre
:
  !0, resim
:
  !0
}
)
r.pseudos [t] = fe(t);
for (t 'de {submit:! 0, reset:! 0}) r.pseudos [t] = de (t); function ve () {} ve.prototype = r.filters = r.pseudos, r .setFilters = new ve, a = oe.tokenize = fonksiyon (e, t) {var n, i, o, a, u, s, l, c = N [e + ""], (c) t döndürüyorsa? 0: c.slice (0); u = e, s = [], i = r.preFilter; iken (u) {n && (i = F.exec (u)) || (i && (u = u!. dilim (i [0] .length) || u), s.push (o = [])), n =! 1 olduğunda (i = z.exec (u)) && (n = i.shift (), o.push ({value: n, type: i [0] .replace ($, "")}), u = u.dilimi (n.length)); (bir r.filter) için! (i = X [a] .exec (u)) || l [a] &&! (i = l [a] (i)) | | (n = i.shift (), o.push ({değer: n, tip: a, eşleşmeler: i}), u = u.slice (n.length)); ? u.length: u? oe.error (e): N (e, s) .slice (0)}; yeğiniz (e) {for (var t = 0, n = e.length, r = "" t <n; t ++) r + = e [t] .value; dönüş r} işlevi bana (e, t, n) {var r = t.dir, i = t.next, o = i || r, a = n && "parentNode" === o, u = T ++; t.first? işlevini döndürür (t, n, i) {while (t = t [r]) ise (1 === t.nodeType || a) return e (t, n, i); dönüş! 1}: işlev (t, n, s) {var l, c, f, d = [C, u]; eğer (ler) {while (t = t [ r)) if ((1 == t.nodeType || a) && e (t, n, s)) geri dönüyor! 0} başka ise (t = t [r]) ise (1 === t.nodeType | | a) durumunda, c = f [t.uniqueID] || ([t.uniqueID] = {} f) i && i === t (t = [x] || (t [x] ' = {}
f
) .
nodeName.toLowerCase()
)
t = t [r] || t;
else
{
  if ((l = c [o]) && l [0] === C && l [1] === u) d
  döndürün [2] = l [2];
  (c [o]
  d = d [2] = e(t, n, s)
)
  geri
  0
}
geri
!1
}
}
işlevi(e)
{
  return e.length > 1 ? İşlevi(t, n, r) {var i = e.length;
  (i -)
  ise(!E [i](t, n)
  ise
  r
))
geri
dönüş
!1;
dönüş
!0
}:
e [0]
}
fonksiyon
xe(e, t, n)
{
  for (var r = 0, i = t.length; r < i; r++) oe(e, t [r], n);
  dönüş
  n
}
fonksiyonu
biz(e, t, n, r, i)
{
  for (var o, a = [], u = 0, s = e.length, l = null! = t;
  u < s;
  u++
)
  (o = e [u]) && (n && !n(o, r, i) || (a.push(o), l && t.push(u)))
  a
  döndürün
  a
}
fonksiyonu
Ce(e, t, n, r, i, o)
{
  dönüş
  r && !r [x] && (r = Ce(r)), i && !i [x] && (i = Ce(i, o))
  ue(işlev(o, a, u, s)
  {
    var l, c, f, d = [], p = [], h = a.length, g = o || xe(t || "*", u.nodeType [u]
  :
    !u, []
  ),
    v = e || o && Tg
  :
      ? = nA, biz(g, d, e, u, s), y
    i || (o
    e : h || r
  )
    []
  :
    a: h(n && n
    d(v, y, u, s), r
  )
    {
      l = biz(y, p), r(l
      ise, [], u, s
    ) ,
      c = l.length;
      ise(c -)(= l [f - c]) &&
    }
    (o)
    {
      (!y = (v [s [] - c] = f) [[]
      p - c
    ])
      (i
      e ||
    )
      {
        (i)
        {
          l = [], c = y.length;
          ise(c -)(f = y [c]) && l.push(v [c] = f)
          ' i (null, y = [], i, s)} c = y.length;ise (C -) (f = y [c]) && (l = ı P (o, m): d [C]?) -> 1 && (o [I] = (a [l] = f)! )}} else y = biz (y === a? y.splice (h, y.length): y), i? i (null, a, y, s): q.apply (a, y)} )} function Te (e) {for (var t, n, i, o = e.length, a = r.relative [e [0] .type), u = a r.relative [""], s = a? 1: 0, c = me (işlev (e) {dönüş e === t}, u,! 0), f = me (işlev (e) {dönüş P (t, e)> - 1 }, u,! 0), d = [işlev (e, n, r) {var i =! a && (r || n! == l) || ((t = n) .nodeTip? c (e, n, r): f (e, n, r)); dönüş t = null, i}]; s <o; s ++) ise (n = r.relative [e [s] .type]) d = [me ] ((d), burada n) başka {halinde ((n = r.filter [e [s] .Tip] .apply (null e [s] .matches)) [x]) {(i = ++ s; i <o; i ++) (r [re [i [i] .type]) bozulursa, Ce (s> 1 && (d), s> 1 && ye (e.slice (0, s-1)) döndürür .concat ({value: "" === e [s-2] .type? "*": ""})). değiştirin ($, "$ 1"), n, s <i && Te (e.slice (ler) i)) i <o && Te (e = e.slice (i)), i <o && ki (e))} d.bas (n)} dönüş (d)} işlevi Ee (e, t) {var n = t.length> 0, i = e.length> 0, o = işlev (o, a, u, s, c) {var f, h, v, y = 0, m = "0", b = o && [], x = [], w = l, T = o || i && r.find.TAG ("*", c) E = C + = boş == 1 w:! Math.random () || .1, N = T.length (c && (l = bir === s || bir || c) için m = ! ' = N && boş = (f = T [m]), m++
        )
  {
    (f
    i
  )
    {
      h = 0 &&,
    ===
      s || (d(f || f.ownerDocument)
      ise, u = g;
    )
      ise(v = [H++])
      halinde(v(f, bir || p, u))
      !{s.push(f)
      'ara} c && (C = s)}, n && ((Rf = hac && f) && Y- , o && b.push (f))} (y + = m, n && m == y) {h = 0;! ise (v = t [h ++]) v (B, x, a, u); (o) {(y> 0) ise (m -) b [m] || x [m] || (x [m] = L.call (ler)), x = (x)} q.apply ( s, x), c &&! o && x.length> 0 && y + t.length> 1 && oe.uniqueSort (s)} dönüş c && (C = E, l = w), b}; dönüş n? ue (o): o} döndür u = oe.compile = işlev (e, t) {var n, r = [], i = [], o = k [e + ""]; eğer (! o) {t || (t = a (e) )), n = t.length;ise, (n -) (o = Te (t [n])) [X] r.push (o): i.push (o), (o = k (E ile (I, R))) .selector = e} geri dönüş o}, s = oe.select = işlev (e, t, n, i) {var o, s, l, c, f, d = "function" == e && e yazın, p =! i (e = d.selector || e) &&, eğer (n = n || [], 1 === p.length) {halinde ((lar p = [0], p [0] .slice = (0) ) .length> 2 && "İD" === (l = kullanıcının [0]). tip && 9 === t.nodeType && g && r.relative [s [1] .Tip]) {halinde (! (t = (r.find. ID (l.uygular [0] .düzey (Z, ee), t) || []) [0])) dönüş n; d && (t = t.parentNode), e = e.slice (s.shift) = X.needsContext.test (e o) .value.length)}) 0: s.length; iken (o -) {(l = s [o], r.relative [c = l.type] ) kırmak, eğer ((= r.find f [c]) && (i = f (l.matches [0] .Kapağı (Z, ee), J.test (lar [0] .Tip) && ge (t. parentNode) || t))) {if (s.splice (o, 1),! (e = i.length && ye (s))) geri dön q.apply (n, i), n; break}}} geri dön d || u (e, s)), (i, t,! g, n,! t || J.test (e) && ge (t.parentNode) || t) n} n.sortStable =, x.split (""). sort (A) .join ("") === x, n.detectDuplicates = !! f, d (), n.sortDetached = se (işlev (e) {return 1 & e.compareDocumentPosition (p .createElement ("fieldset"))}), se (işlev (e) {return e.innerHTML = "<a href='
      #'> </a>", "#" === e.firstChild.getAttribute ( "href")}) || le ("type | href | height | width", işlev (e, t, n) {if (! n) dönüş e.getAttribute (t, "type" === t.toLowerCase ()? 1: 2)}), n.attributes && se (işlev (e) {return e.innerHTML = "<input />", e.firstChild.setAttribute ("value", ""), "" === e.firstChild.getAttribute ("value")}) || le ("value", işlev (e, t, n) {if (! n && "input" === e.nodeName.toLowerCase ()) return e. defaultValue}), se (işlev (e) {return null == e.getAttribute ("disabled")}) || le (H,işlev (e, t, n) {var r; if (! n) geri dönüş! 0 === e [t]? t.toLowerCase () :( r = e.getAttributeNode (t)) && r.specified? r. değeri: boş}), oe} (e) w.find = e w.expr = E.selectors, w.expr [ ":"] = w.expr.pseudos, w.uniqueSort = w.unique e = .uniqueSort, w.text = E.getText, w.isXMLDoc = E.isXML, w.contains = E. içerir, w.escapeSelector = E.escape; var N = işlev (e, t, n) {var r = [], i = void 0! == n; while ((e = e [t]) && 9! == e.nodeType) ise (1 === e.nodeType) {if (i && w (e) .is ( n)) break; r.push (e)} dönüş r}, k = function (e, t) {for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e! = = t && n.push (e); dönüş n}, A = w.expr.match.needsContext; işlev D (e, t) {return e.nodeName && e.nodeName.toLowerCase () === t.toLowerCase ()} var S = / ^ <([az] [^ \ / \ 0>: \ x 20 \ t \ r \ n \ f] *)? [\ x 20 \ t \ r \ n \ f] * \ /> (?: <\ / \ 1> |) $ / i; işlev L (e, t, n) {return g (t)? W.grep (e, işlev (e, r) {dönüş !! t.call (e, ! r, e) == n}): t.nodeType? w.grep (e, fonksiyon (e) {return e === t! == n}): "string"! = tipeof t? w.grep (e, işlev (e) {return s.call ( t, e)> - 1! == n}): w.filter (t, e, n)} w.filter = işlev (e, t, n) {var r = t [0]; dönüş n && (e = ": yok (" + e + ")"), 1 === t.length && 1 === r.nodeType w.find.matchesSelector (r, e): [r]:? []: w.find.matches (e, w.grep (t, fonksiyon (e) {return 1 === e.nodeType}))}, w.fn.extend ({find: function (e) {var t, n, r = bu. length, i = this; if ("string"! = tipeof e) this.pushStack (w (e) .filter (function () {için (t (0; t <r; t ++) değerini döndürürse (w.contains) n = this.pushStack ([]), t = 0 için (;!; i [t], bu)) 0})) geri t <r; t ++) w.find (e, i: [t], n) geri dönüş r> 1? w.uniqueSort (n): n}, filter: function (e) {return this.pushStack (L (bu, e || [],! 1))}, değil: işlev (e) {return this.pushStack (L (bu, e || [],! 0))}, is: function (e) {return !! L (bu, "string" = = e && yazın. T testi (e)? w (e)e || [],! 1) .length}}); var j, q = / ^ (?: \ s * (<[\ W \ W] +>) [^>] * | # ([\ w -] +)) $ /; (w.fn.init = işlev (e, t, n) {var i, o; eğer (! e) bunu döndür; if (n = n || j, "string" = = typeof e) {if (! (i = "<" === e [0] && ">" === e [e.length-1] && e.length> = 3? [boş, e, boş] !: q.exec (e)) || i [1] && t) geri t || t.jquery (t || n) .find (e):? this.constructor (t) .find (e) if (i [1]) {if (t = t instanceof w? t [0]: t, w.merge (bu, w.parseHTML (i [1], t && t.nodeType? t.ownerDocument || t: r 0)), S.test (i [1]) && w.isPlainObject (t)) için (i in t) g (bu [i])? Bu [i] (t [i]): this.attr (i, t [i]); bu dönüşü döndür (o = r.getElementById (i [2])) && (bu [0] = o, this.length = 1), bu} e.nodeType? bu [0] = e, this.length = 1, bu): g (e)? void 0! == n.ready? n.ready (e): e (w): w.makeArray (e, bu) prototype = w.fn, j = w (r); var O = / ^ (?: ebeveynler | prev (?: Until | All)) /, P = {Çocuklar:! 0, içindekiler:!0, next:! 0, prev:! 0}; w.fn.extend ({has: function (e) {var t = w (e, bu), n = t.length; this.filter (işlevini döndür) ) {for (var e = 0; e <n; e ++) ise (w.contains (bu, t [e])) geri dönerse! 0})}, en yakın: function (e, t) {var n, r = 0, i = this.length, o = [], a = "string"! = Yazılan e && w (e); if (! A.test (e)) için (; r <i; r ++) için (n = this) [d] n && n == d; n = n.parentNode) halinde (n.nodeType <11 && (a a.index (n)?> - 1: 1 === n.nodeType && w.find.matchesSelector (n, e))) {o.push (n); break} return this.pushStack (o.length> 1? w.uniqueSort (o): o)}, dizin: işlev (e) {return e? "string" = = typeof e? s.call (w (e), bu [0]): s.call (bu, e.jquery? e [0]: e): this [0] && this [0] .parentNode? this. first (). prevAll (). length: -1}, add: function (e, t) {return this.pushStack (w.uniqueSort (w.merge (this.get (), w (e, t))) )}, addBack: function (e) {return this.add (null == e? this.prevObject: this.prevObject.filtre (e))}}); işlev H (e, t) {while ((e = e [t]) && 1! == e.nodeType); döndürme e} w.each ({parent: function (e) {var t = e.parentNode; dönüş t && 11! == t.nodeType? t: null}, ebeveyn: function (e) {return N (e, "parentNode")}, ebeveynlerUntil: function (e, t, n) {return N (e, "parentNode", n)}, sonraki: function (e) {return H (e, "nextSibling")}, önceki: function (e) {return H (e, "previousSibling")}, nextAll: function (e) {return N (e, "nextSibling")}, prevAll: function (e) {return N (e, "previousSibling")}, nextUntil: işlev (e, t, n) {dönüş N ( e, "nextSibling", n)}, prevUntil: function (e, t, n) {return N (e, "previousSibling", n)}, kardeşler: function (e) {return k ((e.parentNode ||) firstChild, e)}, children: function (e) {return k (e.firstChild)}, içindekiler: function (e) {return D (e, "iframe")? e.contentDocument: (D ( e, "şablon") && (e = e.content || e) w.merge ([], e.childNodes))}} fonksiyonu (yani, t) {w.fn [e] = N fonksiyonu (r) {var i = w.map (this, t, n), "Until" e geri dön! = = e.slice (-5) && (r = n), r && "string" == typeof r && (i = w.filter (r) , i)), bu. uzunluk> 1 && (P [e] || w.uniqueSort (i), O.test (e) && irere ()), this.pushStack (i)}}); var I = / [^ \ x20 \ t \ r \ n \ f] + / g; işlev R (e) {var t = {}; geri dön w.each (e.match (I) || [], işlev (e, n) {t [n] =! 0}), t} w.Callbacks = işlev (e) {e = "string" == typeof e? R (e): w.extend ({}, e); var t, n, r i, o = [], a = [], u = 1, s = fonksiyonu () {(i = i e.once || için, r = t = 0;! a.length u = 1) {n = a.shift (;) ise (++ u <o.length) 1 === o [u] .apply (n [0] n [1]) && e.stopOnFalse && ! = {ekleme}: l (! u = o.length, n = 1)} e.memory || (! n = 1), t = 1, ı ( ""? o = n []): && işlevi () {return o && (n &&! t && (u = o.length-1, a.push (n)),işlev t (n) {w.each (n, işlev (n, r) {g (r)? e.unique && l.has (r) || o.push (r): r && r.length && "dize"! == b (r) && t (r)})} (argümanlar), n &&! t && s ()), bu}, kaldır: function () {return w.each (argümanlar, fonksiyon (e, t) {var n; while ( (n = w.inArray (t, o, n))> - 1) o.splice (n, 1), n ​​<= u && u -}), bu}, şuna sahiptir: function (e) {return e? w .inArray (e, o)> - 1: o.length> 0}, boş: function () {return o && (o = []), bu}, devre dışı bırak: function () {return i = a = [], o = n = "", bu}, devre dışı: function () {return! o}, kilitleme: function () {return i = a = [], n || t || (o = n = ""), this}, locked: function () {return !! i}, fireWith: işlev (e, n) {return i || (n = [e, (n = n || []). dilim? n.slice ( ): n], a.push (n), t || s ()), bu}, yangın: function () {return l.fireWith (this, arguments), this}, tetiklendi: function () {return! ! r}}; dönüş l};fonksiyon B (e) {return e} fonksiyonu M (e) {throw e} fonksiyonu W (e, t, n, r) {var i; deneyin {e && g (i = e.promise)? i.call (e) .done (t) .fail (n): e && g (i = e.then)? i.call (e, t, n): t.apply (void 0, [e] .slice (r))} yakalamak ( e) {n.apply (void 0, [e])}} w.extend ({Ertelenmiş: function (t) {var n = [["notify", "progress", w.Callbacks ("bellek"), Geri çağrılar ("bellek"), 2], ["çözme", "bitti", w.Yeni geri bildirimler ("bir kez bellek"), w.Callbacks ("bir kez bellek"), 0, "çözüldü"], [" reddeder "," başarısız ", w.Callbacks (" bir kez bellek "), w.Callbacks (" bir kez bellek "), 1," reddedildi "]], r =" beklemede ", i = {state: function () { return r}, her zaman: function () {return o.done (argümanlar) .fail (argümanlar), this}, "catch": function (e) {return i.then (null, e)}, pipe: function ( ) {var e = argümanlar; dönüş w.Ertelenmiş (işlev (t) {w.each (n, işlev (n, r) {var i = g (e [r [4]]) && e [r [4]]; o [r [1]] (işlev () {var e = i && i.apply (bu, argümanlar); e && g (e.promise)? e.promise (). progress (t.notify) .done (t.resolve) .fail (t.reject): t [r [0] + "With"] (bu, ben? [e]: argümanlar)})}), e = null}), promise ()}, sonra: function (t, r, i) {var o = 0; işlev a (t, n, r, i) {dönüş işlevi () {var u = bu, s = argümanlar, l = işlev () {var e, l; if (! (T <o)) { if ((e = r.apply (u, s)) === n.promise ()) yeni TypeError ("Kendiliğinden özünürlük") atar; l = e && ("object" == typeof e || "function "== typeof e) && e.then, g (l)" i? l.call (e, bir (o, n, B, i), bir (o, n, M, i)) :( o ++, l .call (e, bir (o, n, B, i), bir (o, n, e, i), bir (o, n, B, n.notifyWith))) :( r! == B && (u = void 0, s = [e]), (i || n.resolveWith) (u, s))}}, c = i? l: function () {try {l ()} yakalamak (e) {w .Deferred.exceptionHook && w.Deferred.exceptionHook (örneğin, s.stackTrace), t + 1> = o && (r! == M && (u = void 0, s = [e]), n.rejectWith (u, s))}}; t? c () :( w.Deferred .getStackHook && (c.stackTrace = w.Deferred.getStackHook ()), e.setTimeout (c))}} return w.Deferred (işlev (e) {n [0] [3] .add (a (0, e) , g: (i) i: B, e.notifyWith)), N- [1] [3] .Add (bir (0, e, g (t), t: B)), N- [2] [3] .add (a (0, e, g (r)? r: M))}) söz ()}, vaat: işlev (e) {return null! = e? w.extend (e, i): i }}, o = {}; geri dönme w.each (n, işlev (e, t) {var a = t [2], u = t [5]; i [t [1]] = a.add, u && .Add (fonksiyonu () {r = u}, n [3-e] [2] .disable, n [3-e] [3] .disable, n [0] [2] .Lock, n [0] [3] .lock), a.add (t [3] .fire), o [t [0]] = function () {return [[t [0] + "With"] (bu === o? void 0: bu, argümanlar), this}, o [t [0] + "With"] = a.fireWith}), i.promise (o), t && t.call (o, o), o}, ne zaman: işlev (e) {var t = arguments.length, n = t, r = Array (n), i = o.call (argümanlar), a = w.Deferred (), u = function (e) {return işlevi ( n) {r [e] = bu,I [e] = arguments.length> 1 o.call (bağımsız): n, - t || a.resolveWith (R, ı)}}, eğer (t <= 1 && (W (e a.done (u (n))., a.reject,! t), "beklemede" === a.state () || g (i [n] && i [n] .then))) geri dönün. ); (n -) W (i [n], u (n), a.reject); a.promise ()}}) değerini döndürür, var $ = / ^ (Eval | Internal | Range | Reference | Syntax | Tür | URI) Hata $ /; w.Deferred.exceptionHook = işlev (t, n) {e.console && e.console.warn && t && $. Test (t.name) && e.console.warn ("jQuery.Deferred özel durum:" + t.message, t.stack, n)}, w.readyException = işlev (t) {e.setTimeout (function () {throw t})} var F = w.Deferred (); w.fn.ready = function (e) {return F.then (e) ["catch"] (işlev (e) {w.readyException (e)}), bu}, w.extend ({isReady:! 1, hazırWait: 1, hazır: function (e) {(! 0 === e - w.readyWait:? w.isReady)!! || (w.isReady = 0, 0 == e && - w.readyWait> 0 || F.resolveWith (r,[w]))}}) w.ready.then = F.then; function z () {r.removeEventListener ("DOMContentLoaded", z), e.removeEventListener ("load", z), w.ready ( )} === r.readyState || "yükleme" "tam"! == r.readyState &&! r.documentElement.doScroll? e.setTimeout (w.ready) :( r.addEventListener ( "DOMContentLoaded", z), e.addEventListener ("load", z)); var _ = function (e, t, n, r, i, o, a) {var u = 0, s = e.length, l = null == n; if ("object" === b (n)) {i =! 0; (u, n için) _ (e, t, u, n [u],! 0, o, a)} else (if) 0! == r && (i =! 0 gr (r) || (a =! 0), l && (a? (t.call (e, r) t = null) :( l = t, t = işlev (e, t, n) {return l.call (w (e), n)})), t)) için (; u <s; u ++) t (e [u], n, a? r: r.call (e [u], u, t (e [u], n))), i? e: l? t.call (e): s? t (e [0], n): döndür }, U = / ^ - ms - /, V = / - ([az]) / g; işlev X (e, t) {dönüş t.toUpperCase ()} işlevi Q (e) {return e.replace (U) , "MS -".) yerine (V,X)} var Y = fonksiyon (e) {return 1 === e.nodeType || 9 === e.nodeType ||! + E.nodeType}; işlev G () {this.expando = w.expando + G.uid ++} G.uid = 1, G.prototype = {cache: function (e) {var t = e [this.expando]; dönüş t || (t = {}, Y (e) && (e. nodeType e [this.expando] = t: Object.defineProperty (e this.expando {değeri: t, yapılandırılabilir: 0}))) t}, set: fonksiyonu (e, t, n) {var r, i = this.cache (e); if ("string" == typeof t) i [Q (t)] = n; else (r in t için) i [Q (r)] = t [r] i}, get: function (e, t) {return void 0 ===t? this.cache (e): e [this.expando] && e [this.expando] [Q (t)]}, erişim : işlev (e, t, n) {return void 0 === t || t && "string" == türkçe t && void 0 === n? this.get (e, t) :( this.set (e, t , n), void 0! == n? n: t)}, kaldır: function (e, t) {var n, r = e [this.expando]; if (void 0! == r) {if ( void 0! == t) {n = (t = Array.isArray (t)? t.map (Q) :( t = Q (t)) r? [t] '
      de: t.uygun(I) ||
    .
      []
    )
uzunluğu;
while (n -) delete r [t [n]]
}
(void 0 === t || w.isEmptyObject(r)) && (e.nodeType ? e [this.expando] = void 0 : silme
e [this.expando]
)
}
},
hasData: function (e) {
  var t = e [this.expando];
  dönüş
  geçersiz
  0
  ! == t && !w.isEmptyObject(t)
}
}
;var K = yeni
G, J = yeni
G, Z = / ^ (?: \ {[\ w \ W] * \} | \ [[\ w \ W] * \]) $ /, ee = / [AZ] /
g;
işlev
te(e
!
)
{
  "true" === e || "yanlış" == e && dönmek ? (? : e === +e + "" + e : ? "boş" === e boş
  Z.test(e)
  JSON.parse(e)
:
  e
)
}
ne(e, t, n)
{
  var r;
  if (void 0 === n && 1 === e.nodeType) ise(r = "data -" + t.replace(ee
  "- $ &".
)
  toLowerCase(), "dize" == typeof (n = e.getAttribute(r))
)
  {
    try {
      n = n
      te()
    } catch (e) {
    }
    J.set(e, t, n)
  }
else
  n = void 0;
  dönüş
  n
}
w.extend({
  hasData: function (e) {
    dönüş
    J.hasData(e) || K.hasData(e)
  }, veri: işlev(e, t, n)
{
  return J.access(e, t, n)
}
,
removeData: işlev(e, t)
{
  J.remove(e, t)
}
,
_
veri: işlev(e, t, n)
{
  dönüş
  K.erişim(e, t, n)
}
,
_
removeData: function (e, t) {
  K.remove(e, t)
}
}),
w.fn.extend({
  data: function (e, t) {
    var n, r, i, o = bu [0], a = o && o.attributes;
    if (void 0 === e) {
      if (this.length && (i = J.get(o), 1 === o.nodeType && !K.get(o, "hasDataAttrs"))) {
        n = a.length;
        sırasında(n -)
        bir [n] && 0 === (r = a [n].name).indexOf("veri-") && (r = Q(r.slice(5)), ne(o, r, i [r]));
        K.set(o, "hasDataAttrs", !0)
      }
      return i
    }
    "object"
    döndürür = = typeof e ? this.each(function () {
      J.set(this, e)
    }) : _(bu, function (t) {
      var n;
      if (o && void 0 === t) {
        if (boşluk 0
        ! == (n = J.get(o, e))
      )
        dönüş
        n;
        eğer(void 0
        ! == (n = ne(o, e))
      )
        geri
        dönüş
        n
      } else this.each(function () {
        J.set(this, e, t)
      })
    }, null, t, arguments.length > 1, null, !0)
  }, removeData: function (e) {
    return this.each(işlev()
    {
      J.remove(bu, e)
    }
  )
  }
}), w.extend({
  queue: function (e, t, n) {
    var r;
    eğer(e)
    t = (t || "fx") + "sıra", r = döndürür
    K.[(R.push(n)
    r - || Array.isArray(n)
    r = K.access(E, T, N
    w.makeArray()
  )
    ! ?
  ),
    R || (yani, t)
    elde
    n &&
  ]
  }, dequeue: function (e, t) {
    t = t || "fx";
    var n = w.queue(e, t), r = n.length, i = n.shift(), o = w._queueHooks(e, t), a = fonksiyonu()
    {
      w.dequeue(yani, t)
    }
    ;"InProgress" === i && (i = n.shift(), r -), i && ("fx" === t && n.unshift("devam etmekte olan"), o.stop
    dosyasını
    sil, i.call(e, a, o)
  ) ,
    !r && o && o.empty.fire()
  }, _ queueHooks
:

function (e, t) {
  var =
  t + "queueHooks", K.get(e, n) || K.access(e, n, {boş: w.Callbacks("bir kez bellek") döndürür.(function () {
    K.remove(e, [t + "sıra", n])
  })
})
}
}),
w.fn.extend({sıra: işlev(e, t)
{
  var n = 2;
  dönüş
  "string"
  ! = typeof e && (t = e , e = "fx", n -), arguments.length < n ? w.queue(this [0], e) : void 0 === t ? this : this.each(function () {
    var n = w.queue(bu, örneğin, t);
    w._queueHooks(bu, e)
    "fx " === e && " devam ediyor "
    ! == n [0] && w.dequeue(bu, e)
  })
}
,
dequeue: function (e) {
  return this.each(function () {
    w.dequeue(bu, e)
  })
}
,
clearQueue: function (e) {
  return this.queue(e || "fx", [])
}
,
vaat: işlev(e, t)
{
  var n, r = 1, i = w.Deferred(), o = bu, a = this.length, u = function () {
    -r || i.resolveWith(o, [o])
  };
  "string"
  ! = E && yazın(t = e, e = void 0), e = e || "fx";
  (a -)(n = K.get(o [a], e + "queueHooks")) && n.empty && (r++, n.empty.add(u));
  u(), i.promise(t)
}
})
döndürür,
var re = / [+ -]? (?: \ d * \. |) \ d + (?: [eE] [+ -] ? \ d + |) /.source,
  ie = new RegExp("^ (?: ([+ -]) = |) (" + re + ") ([az%] *) $", "i"), oe = ["en", "sağ", "alt", "sol"],
  ae = fonksiyonu(yani, t)
{
  dönüş
  "yok" === (e = t || e).style.display || " " === e.style.display && w.contains(e.ownerDocument, e) && "none" === w.css(e, "display")
}
,
ue = function (e, t, n, r) {
  var i, o, a = {};
  için(o
  içinde
  t
)
  a [o] = e.style [o], e.style [o] = t [o];
  i = n.apply(e, r || []);
  [o] = a [o];
  return i
};
işlev
se(e, t, n, r)
{
  var i, o, a = 20, u = r ? işlevi() {return r.cur()}
:

  function () {
    return w.css(e, t, "")
  }

,
  s = u(), l = n && n [3] || (w.cssNumber [t] ? "" : "px"), c = (!w.cssNumber [t] || "piksel" == l && +s) && ie.exec(w.css(yani, t)), eğer(c
  ! && c [3] == l
)
  {
    s / = 2, l = l || c [3], c = +s || 1;
    ise, (a -)
    w.style(e, t, c + l)(1 - o) * (1 - (o = u() / s || .5)) <= 0 && (a = 0), c / = o, c * = 2, w.style(e, t, c + l)
    için
    n = n || []
  }
  dönüş
  n && (c = +c || +s || 0, i = n [1] ? c + (n [1] + 1) * n [2] : +n [2], r && (r.unit = l , r.start = c, r.end = i)), i
}
var le = {};
işlev
ce(e)
{
  var t, n = e.ownerDocument, r = e.nodeName, i = le [r]
  i || (t = n.body.appendChild(n.createElement(r)), i = w.css(t, "display"), t.parentNode.removeChild(t), "none" === i && (i = "block"), le [r] = i, i)
}

function fe(e, t) {
  for (var ) n, r
  i = [], o = 0, a = e.length;
  o < a;
.
  o++
)

(r = e [o])
stil && (n = r.style.display, t, ("yok" ? === n && (i [o] = K.get(r, "ekran") || boş
i [o] || (r.style.display = "")
)
"" === r.style.display && ae(r) && (i [o] = ce(r))
):
"yok" == n && (i [o] = "yok", K.set(r, "ekran"
n
)))
(o = 0;
o < a;
o++
)
null
! = i [o] && (e [o].style.display = i [o]);
dönüş
e
}
w.fn.extend({show: function)()
{
  return fe(this, !0)
}
,
gizleyin: function () {
  return fe(this)
}
,
geçiş: function (e) {
  return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function () {
    ae(this) ? w(this).show() : w(this).hide()
  })
}
})
;var de = / ^ (?: kutusunun | radyo) $ /
i, pe = / <([az] [^ \ / \ 0> \ x 20 \ t \ r \ n \ f] +) /
i, o = / ^ $ | ^ module $ | \ /(? : java | ecma)
script / i, ge = {
  option: [1, "<select multiple = 'multiple'>", "</ select>"],
  thead: [1, "<tablo>", "</ table>"],
  sütun: [2, "<tablo> <COLGROUP>", "</ COLGROUP> </ table>"],
  t,
:
[2, "<tablo> <tbody>", "</ tbody> </ table>"], td
:
[3, "<tablo> <tbody> <tr>", "</ tr> </ tbody> </ tablo > "]
_
varsayılan: [0, "", ""]
}
;ge.optgroup = ge.option, ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td;

function ve(e, t) {
  var n;
  dönüş
  n = "undefined"
  ! = typeof e.getElementsByTagName ? e.getElementsByTagName(t || "*") : "undefined"
  ! = typeof e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && D(e, t) ? w.merge([e], n) : n
}

işlevi
siz(e, t)
{
  for (var n = 0, r = e.length; n < r; n++) K.set(e [n], "globalEval", !t || K.get(t [n], "globalEval"))
}
var me = / <| & #? \ w +; /;
işlevi(e, t, n, r, i)
{
  için(
  var o, a, u, s, l, c, f = t.createDocumentFragment(), d = [], p = 0, h = e.length;
  p < h;
  p++
)
  ise((o = e [p]) || 0 === o)
  if ("object" === b(o)) w.merge(d, o.nodeType ? [o] : o), eğer(me.Test(o))
  {
    a = a || f.appendChild(t.createElement("div")), u = (pe.exec(o) || ["", ""]) [1].toLowerCase(), s = ge [u] || ge._default, a.innerHTML = s [1] + w.htmlPrefilter(o) + s
  :
    [2], c = s [0];
    ise(c -), a = a.lastChild;
    w.merge(d, a.childNodes), (a = f.firstChild).textContent = ""
  }
else
  d.push(t.createTextNode(o));
  f.textContent = "", p = 0;
  (o = d [p++])
  ise(r && w.inArray(o, r) > -1)
  i && i.push(o);
else
  ise(l = w.contains(o.ownerDocument, o), a = ettik(f.appendChild(o), "script"), l && ye(a), n)
  {
    c = 0;
    iken(o = a [c++])
    o.test(o.type || "") && n.push(o)
  }
  döndürme
  f
}
!function () {
  var e
.
  = r.createDocumentFragment()
  appendChild(r.createElement("div")), t = r.createElement("giriş");
  t.setAttribute("türü", "radyo"), t.setAttribute("kontrol",), t.setAttribute("ad", "t"), e.appendChild(t)
  "işaretli", h.checkClone = e.cloneNode(!0).cloneNode(!0), e.lastChild.checked.innerHTML = "<textarea> x </ textarea>", h.noCloneChecked = !!e.cloneNode(!0).lastChild.defaultValue
}();
var xe = r.documentElement, biz = / ^ anahtar /, Ce = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
  Te = /^([^.]*)(?:\.(.+)|)/;

function Ee() {
  return !0
}

fonksiyonu
Ne()
{
  return !1
}
fonksiyonu
ke()
{
  try {
    geri
    dön
    r.activeElement
  } catch (e) {
  }
}
işlevi
Ae(e, t, n, r, i, o)
{
  var a, u;
  if ("object" == typeof t) {
    "string "
    ! = typeof n && (r = r || n, n = void 0);
    (u in t)
    için
    " Ae (e, u, n, r, t [u], o); dönüş e} if (null) == r && null == i? (i = n, r = n = void 0): null == i && ("
    string
    " == typeof n? (i = r, r = void 0) :( i = r, r = n, n = void 0)),! 1 === i) i = Ne; başka bir şey (! i) e döndürürse, return 1 === o && (a = i, (i = function (e) {return (). kapalı (e) a.apply (bu, bağımsız değişkenler)}). guid = a.guid || (a.guid = w.guid ++)), e.each (fonksiyonu () {w.event w. ekle (this, t, i, r, n)})} w.event = {global: {}, ekleyin: işlev (e, t, n, r, i) {var o, a, u, s, l , c, f, d, s, h, g, h = K.get (e), (v) {n.handler && (n = (o = n) .handler i = o.selector) i ağırlık && ise. find.matchesSelector (Xe, i) n.guid || (n.guid = w.guid ++), (s = v.events) || (s = v.events = {}), (a = v.handle ) || (a = v.handle = işlev (t) {return "
    undefined
    "! = yazarak w && w.event.triggered! == t.type? w.event.dispatch.apply (e, argümanlar): void 0} ), I = (t = (|| "
    "). eşleme (I) 'e || [ "
    "]) uzunluğu.;p = g = (U = Te.exec (t [l]) || []) [1], h = (U [2] || "
    "). bölme ( "
    ") - (L) da ? = w.event.special [p] || {} p = (i f.delegateType f .sort (), s && (: f.bindType) || p = w.event.special [p] f | | {}, c = w.extend ({türü: s, origType: g, veriler: r, işleyici: n, rehberlik: n.guid, seçici: i needsContext i w.expr.match.needsContext.test && (i ), ad: "
    " h.join ()}, o), (D = kullanıcının [p]) || ((d = s [p] = []) delegateCount = 0, f.setup && 1.! == f.setup.call (e, r, s, a) '|| e.addEventListener && e.addEventListener (s, a)), && f.add (f.add.call (yani, c) c.handler.guid || (c.handler.guid = n.guid)), i d.splice (d.delegateCount ++ 0, c): d.push (c) w.event.global [p] = 0)}! }, remove: function (e, t, n, r, i) {var o, a, u, s, l, c, f, d, p, h, g, v = K.hasData (e) && K. (e) elde, eğer (v && (s = v.events)) {l = (t = (|| "
    ") eşleşme (I) 'e ||. [ "
    "]) uzunluğu;. iken (ben-) eğer (u = Te.exec (t [l]) || [], s = g = u [1], h = (u [2] ||"
    ") .Split ("
    ") sıralama () p) {f = w.event.special [p] || {}, d = kullanıcının [(p = r f.delegateType.:.? F.bindType) | | p] || [], u = u [2] && new RegExp ("( ^ | \\.)
    " + h.join ("\\.
    (? :. * \\. |)
    ") + "( \\. |
    $
  )
    "), a = o = d.length;! ise (o -) c d = [a] ,! i g && == c.origType || n && n.guid == c.guid | |! u && u.test (c.namespace) || r && r == c.selector && ( " ** " == r || c.selector!) || (d.splice (o, 1), c!. seçici && d.delegateCount -, f.remove && f.remove.call (e), c),! (! f.teardown && 1 == f.teardown.call (e, h, v.handle) bir && d.length && || w.removeEvent (e, p, v.handle), s [p] 'i sil), (ws) s' için (s.w.event.remove) (e, p + t [l], n, r,! 0); w.isEmptyObject (s) && K.remove (e, "
    olayları
    işlemek
    ")}}, gönderme: function (e) {var t = w.event.fix (e), n, r, i, o, a, u , s = new Array (arguments.length), l = (K.get (bu, "
    olaylar
    ") || {}) [t.tipi] || [], c = w.event.special [t.type] || {}; için (ler [0] = t, n = 1 'dir; n, <arguments.length n ++) s [n] = argümanlar [n], eğer (!! t.delegateTarget = Bu, c.preDispatch || 1 == c.preDispatch.call (bu, t)) {u = w.event.handlers.call (bu, t, l) için n = 0; iken ((o = u [n ++]) && t.isPropagationStopped ()) {t.currentTarget = o.elem, r = 0; while ((a = o.handlers [r ++]) &&! t.isImmediatePropagationStopped ()) t.rnamespace &&! t.rnamespace.test (a.namespace) || (t.handleObj = a, t.data = a.data, boşluk 0! == (i = ((w .event.special [a.origType] || {}). .apply) || a.handler kolu (o.elem, s)) &&! 1 === (t.result = ı) && (t.preventDefault (), t.stopPropagation ()))} return c.postDispatch && c.postDispatch.call (bu, t), t.result}}, işleyicileri: function (e, t) {var n, r, i, o, a u = [], s = t.delegateCount, l = e.target; if (! s && l.nodeType && ( "
    click
    " === e.type && e.button> = 1)) (için;! l == bu; l = l.parentNode || Bu) halinde (1 === l.nodeType && (== e.type || "
    klik
    "! 0! == l.disabled)) {(o = [], a = {}, n, = 0; n <s; n ++) void 0 === a [i = (r = t [n]) seçici + "
    "] && (a [i] = r.needsContext? W (i, bu). İndex (i) -> 1: w.find (i, bu, boş [l]) uzunluk) [i] && o.push (r); o.length && u.push ({elem: l, yükleyiciler: o. })} return l = bu, s <t.length && u.push ({elem: l, işleyicileri: t.slice (s)}), u}, addProp: function (e, t) {Object.defineProperty (w. Event.prototype, e, {enumerable:! 0, yapılandırılabilir:! 0, get: g (t)? Function () {if (this.originalEvent) t döndürür (this.originalEvent)}: function () {if (this) .originalEvent) this.originalEvent [e]} değerini döndür, set: function (t) {Object.defineProperty (bu, e, {numaralandırılabilir:! 0, yapılandırılabilir:! 0, yazılabilir:! 0, value: t})}} )}, düzelt: function (e) {return e [w.expando]? e: yeni w.Event (e)}, özel: {load: {noBubble:! 0}, odaklama: {tetikleyici: function () { if (bu! == ke () && this.focus) this.focus (),! 1} döndürün, delegateType: "
    focusin
    "}, blur: {trigger: function () {if (this === ke () && this.blur) this.blur () öğesini döndürün ,! 1}, delegateType: "
    focusout
    "}, tıklayın: {trigger: function () {if ("
    checkbox
    " === this.type && this.click && D (this, "
    input
    ")) this.click () döndürün! 1}, _ default: function (e) {return D (e.target, "
    a
    ")}}, beforeunload: {postDispatch: işlev (e) {void 0! == e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)}}}} w.removeEvent = fonksiyonu (e, t, n) {e.removeEventListener && e.removeEventListener (t, n)}, w.Event = fonksiyonu (yani, t); {halinde (! ( Bu instanceof w.Event)) new w.Event (e, t); e && e.type? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 == = e.defaultPrevented && 1 === e.returnValue Ee:!? Ne bu.Hedef = e.target && 3 === e.target.nodeType e.target.parentNode: e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget): this.type = E, t && w.extend (Bu, t); this.timeStamp = e && e.timeStamp || Date.now (), bu [w.expando] = 0}, w.Event.prototype = {yapıcı: w.Event, isDefaultPrevented: Hayır, isPropagationStopped : Ne, IsImmediatePropagationStopped: Ne, isSimulated:! 1, preventDefault: function () {var e = this.originalEvent; this.isDefaultPrevented = Ee, e &&! This.isSimulated && e.preventDefault ()}, stopPropagation: function () {var e = this.originalEvent; this.isPropagationStopped = Ee, e &&! this.isSimulated && e.stopPropagation ()}, stopImmediatePropagation: function () {var e = this.originalEvent; this.isImmediatePropagationStopped = Ee, e &&! this.isSimulated && e.stopImmediatePropagation () , this.stopPropagation ()}} w.Her ({altKey: 0, kabarcıklar: 0, cancelable:! 0, changedTouches: 0, ctrlKey:! 0, detay:! 0, eventPhase: 0, metakey: 0, pageX: 0, SayfaY: ! 0, shiftKey: 0, görünümü:! 0 "
    karakter
    ":! 0, charCode: 0, anahtar: 0, keyCode: 0, düğme: 0, düğmeler: 0, clientX: 0, clientY: 0, offsetX: 0, offsetY: 0, pointerId: 0, pointerType: 0, screenX: 0, screenY: 0, targetTouches: 0, toElement: 0, dokunuyor: 0, hangi: function (e) {var t = e.button; dönüş null == e.which && we.test (e.type)? null! = e.charCode? e.charCode: e.keyKodu:! e.which && void 0! ? == t && Ce.test (e.type) 1 ve t, 1: 2 ve t 3: 4-t2: 0: e.which}} w.event.addProp), w.each ({MouseEnter: "
    fare
    ", mouseLeave "
    mouseout
    ", pointerenter: "
    pointerover
    ", pointerleave: "
    pointerout
    "}, fonksiyon (örneğin, t) {w.event.special [e] = {delegateType: t, bindType: tR işlemek: fonksiyonunu (e) { var n, r = bu, i = e.relatedTarget, o = e.handleObj;i && (i === r || w.contains (r, i)) || (e.type = o.origType, n = o.handler.apply (bu, argümanlar), e.type = t), n}}}), w.fn.extend ({on: işlev (e, t, n, r) {return Ae (bu, e, t, n, r)}, bir: işlev (e, t, n) , r) {return Ae (bu, e, t, n, r, 1)}, kapalı: işlev (e, t, n) {var r, i; eğer (e && e.preventDefault && e.handleObj) geri dönüş r = e. handleObj, w (e.delegateTarget) .off (r.namespace? r.origType + ".
    " + r.namespace: r.origType, r.selector, r.handler), bu; eğer ("
    object
    " == typeof e) ) {for (i e) this.off için (i, t, e [i]), geri döndürün} return! 1! == t && "

    function

    "! = typeof t || (n = t, t = void 0 1 === n && (n = Ne), this.each (işlev () {w.event.remove (bu, e, n, t)})}}); var De = / <(?! alan | br | col | yerleştirme | saat | img | giriş | bağlantı | meta | param) (([az] [^ \ / \ 0> \ x 20 \ t \ r \ n \ f] *) [^>] * ) \ /> / gi, Se = / <script | <style | <link / i, Le = / kontrol \ s * (?:. [^ =] | = \ s * .checked) / i, je = / ^ \ s * <! (?:\ [CDATA \ [| -] | (?: \] \] | -)> \ s * $ / g; işlev qe (e, t) {return D (e, "
    tablo
    ") && D (11! == t.nodeType? t: t.firstChild, "
    tr
    ")? w (e). çocuklar ("
    tbody
    ") [0] || e: e} işlev Oe (e) {return e.type = (null ! == e.getAttribute ("
    type
    ")) + " / " + e.type, e} fonksiyonu Pe (e) {return "
    true / " === (e.type || "
    "). dilim (0) , 5)? E.type = e.type.slice (5): e.removeAttribute ("
    type
    "), e} fonksiyonu He (e, t) {var n, r, i, o, a, u, s , I, eğer (1 === t.nodeType) {halinde (K.hasData (e) && (o = K.access (e), a = K.set (t, o) l = o.events) ) {delete a.handle, a.events = {}; (i için l) için (n = 0, r = l [i] .length; n <r; n ++) w.event.add (t, i , l [i] [n])} J.hasData (e) && (u = J.access (e), s = w.extend ({}, u), J.set (t, s))}} işlev Ie (e, t) {var n = t.nodeName.toLowerCase (); "
    girdi
    " === n && de.test (e.type)? t.checked = e.checked: "
    input
    "! == n && "
    textarea
    "! == n || (t.defaultValue = e.defaultValue)} fonksiyon Yeniden (e, t, n, r) {t = a.apply ([], t); var i, o, u, s , l, c, f = 0, d = e.length, p = d-1, v = t [0], y = g (v); if (y || d> 1 && "
    string
    " == typeof v && ! h.checkClone && Le.test (v)) e.each'i döndürür (function (i) {var o = e.eq (i); y && (t [0] = v.call (this, i, o.html ()) )) Re (o, t, n, r)};) (d && (i = olması halinde (t, e [0] .ownerDocument, 1, e, r) o = i.firstChild, 1 == = i.childNodes.length && (i = o), o || r)) {(s = (u = w.map (ve (i, "
    komut
    "), Oe)) uzunluğu; f. <d, f ++ ) l = i, F! == p && (l = w.clone (l, l! 0! 0), s && w.merge (u, ve, (l, l "
    komut
    "))), n.call (e [f ], l, f) eğer (lar) ı (c = u [u.length-1] .ownerDocument, w.map (u, Pe için), f = 0; f <s f ++), l = u [f ], he.test (l.type || "
    ") && K.access (l! "
    globalEval
    ") && w.contains (c, l) && (l.src && "
    modül
    " == (l.type! | | "
    ").toLowerCase ()? w._evalUrl && w._evalUrl (l.src): m (l.textContent.replace (je, "
    "), c, l))} döndürme e} işlevi Be (e, t, n) {için ( var r, i = t? w.filter (t, e): e, o = 0; null! = (r = i [o]); o ++) n || 1! == r.nodeType || w. cleanData (ve (r)), r.parentNode && (n && w.contains (r.ownerDocument, r) && ye (ve (r, "
    script
    ")), r.parentNode.removeChild (r)), döndürme e} w.extend ({htmlPrefilter: function (e) {return e.replace (De, " < $
    1 > < / $ 2>")}, klon: function (e, t, n) {var r, i, o, a, u = (! 0) e.cloneNode, s = w.contains (e.ownerDocument, e) if ((|| 1 h.noCloneChecked == e.nodeType && 11 == e.nodeType || w.isXMLDoc (e! ))), (a = ettik için (u), r = 0, i = (= (e)) ve y uzunluğu;. r <i, r ++) Ie (o [d], bir [d]), eğer ( t); (e (o = O || ziyaretinde (n)), a = a || ziyaretinde halinde (u), r = 0, i = o.length, r, <i, r ++), O (O [d] , bir [r]), başka (o, e), geri (a = ve (u, "betik")). uzunluk> 0 && ye (a,! s && ve (e, "script"))), u}, cleanData: function (e) {for (var t, n, r, i = w.event.special, o = 0; void 0! == (n = e [o]); o ++) eğer (Y (n)) {if (t = n [K.expando]) {if (t.events) için (r in t.events) i [r]? w.event.remove (n, r): w.removeEvent (n, r, t.handle); n [K.expando] = void 0} n [J.expando] && (n [J.expando] = void 0)}}}), w.fn. genişlet ({ayırma: işlev (e) {dönüş Be (bu, e,! 0)}, kaldır: işlev (e) {dönüş Be (bu, e)}, metin: işlev (e) {dönüş _ (bu, function (e) {return void 0 === e? w.text (this): this.empty (). her (function () {1! == this.nodeType && 11! == this.nodeType && 9! == this. nodeType || (this.textContent = e)})}, null, e, arguments.length)}, ekle: function () {return Re (bu, argümanlar, fonksiyon (e) {1! == this.nodeType && 11! == this.nodeType && 9! == this.nodeType || qe (bu, e) .appendChild (e)})}, prepend: function () {return Re (bu, argümanlar, fonksiyon (e) {if (1 = == this.nodeType || 11 === this.nodeType || 9 === bu.nodeType) {var t = qe (this, e); t.insertBefore (e, t.firstChild)}})}, önce: function () {return Re (bu, argümanlar, function (e) {this.parentNode && this. parentNode.insertBefore (e, this)})}, sonra: function () {return Re (bu, argümanlar, işlev (e) {this.parentNode && this.parentNode.insertBefore (e, this.nextSibling)})}, boş: function () {for (var e, t = 0; null! = (e = this [t]); t ++) 1 === e.nodeType && (w.cleanData (ve (e,! 1)), e. textContent = ""); bunu geri döndürün}, klon: function (e, t) {return e = null! = e && e, t = null == t? e: t, this.map (function () {return w.clone (bu, e, t)})}, html: function (e) {return _ (bu, function (e) {var t = this [0] || {}, n = 0, r = this.length; if (void 0 === e && 1 === t.nodeType) t.innerHTML değerini döndürürse, eğer ("string" == typeof e &&! Se.test (e) &&! ge [(pe.exec (e) || [ "", ""]) [1] .toLowerCase ()]) {e = w.htmlPrefilter (e) için ({deneyin;n <r n ++), 1 === (t = bu [n] || {}) noteType && (w.cleanData (ve (t, 1).!), t.innerHTML = e) t = 0} yakalamak (e) {}} t && this.empty ()., (e)} ekini, null, e, arguments.length)}, replaceWith: function () {var e = []; Re (bu, argümanlar, fonksiyon (t) ) {var n = this.parentNode; w.inArray (bu, e) <0 && (w.cleanData (ve (bu)), n && n.replaceChild (t, bu))}, e)}}), w. ({appendTo: prependTo "ekleme": "başına", insertBefore: InsertAfter "daha önce": "sonra" replaceAll: "replaceWith"}, fonksiyon (örn, t) {[e] = fonksiyon (e w.fn ) {for (var n, r = [], i = w (e), o = i.length-1, a = 0; a <= o; a ++) n = a === o? bu: bu. clone (! 0), w (i [a]) [t] (n), u.apply (r, n.get ()); this.pushStack (r)}}) döndürür, var Me = new RegExp ( "^ (" + re + ") (?! px) [az%] + $", "i"), We = işlev (t) {var n = t.ownerDocument.defaultView; dönüş n && n.opener || (n = e) n.getComputedStyle (t)}, $ e = yeni RegExp (oe.join ("|"), "i") ;! function () {function t () {if (c) {l.style.cssText = "konum: mutlak, sol: -11111px; genişliği: 60 piksel, kenar üstü: 1 piksel; doldurma: 0; sınır: 0" , c.style.cssText = "pozisyonu: göreceli; görüntü: blok, kutu boyutlandırma: sınır-kutu; taşma : kaydırma; kenar boşluğu: otomatik; kenarlık: 1px; dolgu: 1px; genişlik:% 60; üst: 1% ", xe.appendChild (l) .appendChild (c); var t = e.getComputedStyle (c); i = "% 1"! == t.top, s = o, 12 === n (t.marginLeft), = "% 60" c.style.right u 36 === n (t.right) = = 36 === n (t.width), c.style.position = "mutlak", a = 36 === c.offsetWidth || "mutlak", xe.removeChild (l), c = null}} işlev n (e) {dönüş Math.round (parseFloat (e))} var, o, a, u, s, l = r.createElement ("div"), c = r.createElement ("div"), c. tarzı && (c.style.backgroundClip = "content-box", c.cloneNode (! 0) .Style.backgroundClip = "", h.clearCloneStyle = "içerik kutusu" === c.style.backgroundClip, w.extend (h, {boxSizingReliable: function () {return t (), o}, pixelBoxStyles: işlev () { t (), u}, pixelPosition: function () {return t (), i}, reliableMarginLeft: function () {return t (), s}, scrollboxSize: işlev () {return t (), a}} ))} (); işlev Fe (e, t, n) {var r, i, o, a, u = e.style; dönüş (n = n || Biz (e)) && (""! == (a = n.getPropertyValue (t) || n [t]) || w.contains (e.ownerDocument e) || (a = w.style (yani, t)) ,! h.pixelBoxStyles () && Me .test (a) '&& $ e.test (t) && (r = u.width, i = u.minWidth, o = u.maxWidth, u.minWidth = u.maxWidth = u.width = a, a = n .width, u.width = r, u.minWidth = i, u.maxWidth = o)), void 0! == a? a + "": a} işlevi ze (e, t) {return {get: function ( ) {if (! e ()) return (this.get = t) .apply (this, arguments); silmek this.get}}} var _e = / ^ (none | table(? !-c [ea]). *) /, Ue = / ^ - /, Ve = {
      pozisyonu: "mutlak",
      görüş "gizli",
      görüntü: "blok"
    }
    Xe
    'nin = {harf "0" ise, fontWeight: "400"}, Qe = [ "Webkit'
    teki
    ", "
    Moz
    ","
    ms
    "], Ye = r.createElement ("
    div
    ") stili, işlev Ge (e) {if (e in Ye) e döndürür; var t = e [0] .toUpperCase () + e.slice (1) , n = Qe.length; (n -) ise, Ye () 'de ((e = Qe [n] + t) döndürdüğünde e} fonksiyonu Ke (e) {var t = w.cssProps [e]; t dönüşü | | (t = w.cssProps [e] = Ge (e) || e), t} fonksiyonu Je (e, t, n) {var r = yani.exec (t); getiri r = Math.max (0 , r [2] - (n || 0)) + (r [3] || "
    px
    "): işlev Ze (e, t, n, r, i, o) {var a = "
    genişlik
    " === t? 1: 0, u = 0, s = 0; eğer (n === (r? "
    kenarlık
    ": "
    içerik
    ")) 0 değerini döndürür; (; a <4; a + = 2) "
    marjı
    "=== n && (s + = w.css (e, n + oe [a] ,! 0, i)), ki burada r ("
    içerik
    "=== n && (s- = w.css (e"
    dolgu
    "+ oE [a] ,! 0, i)),"
    sınır
    "! == n && (s-w =.CSS (yani, "
    sınır
    " + oe [a] + "
    genişliği
    ",! 0, i))) :( s + = w.css (yani, "
    doldurma
    " + oe [a] ,! 0, i)"
    dolgu
    "(sınır " + oe [a] + " genişliği", 0, i
    !u + = w.css(e == n
    s + = w.css
    e
  )
    "!?"
    sınır
    " + oe [a] + "
    genişliği
    ", 0, i));! r! && o> = 0 && (s + = Math.max (0, math.ceil (e geri [ "
    ofset
    " + t [0] .toUpperCase () + t.slice ( 1)] - osu-.5))), s} fonksiyonu et (e, t, n) {var r = Biz (e), i = Fe (e, t, r), o = "
    kenar - kutusu
    " === w.css (e, "
    boxSizing
    ",! 1, r), a = o; if (Me.test (i)) {if (! n) dönüş i; i = "
    auto
    "} a döndürür a = bir && (h.boxSizingReliable () || i === e.style [t]), ( "
    otomatik
    " === n (e) {return !! (e.offsetWidth || e.offsetHeight || e.getClientRects (). uzunluk)}, h.createHTMLDocument = function () {var e = r.implementation.createHTMLDocument ("
    "). body; return e.innerHTML = " < form > < / form> <form> </
    form > ", 2 === e.childNodes.length} (), w.parseHTML = işlev (e, t, n) { if ("
    string
    "! = typeof e) return []; "
    boolean
    " == typeof t && (n = t, t =! 1); var i, o, a; dönüş t || (h.createHTMLDocument? (( i = (t = r.implementation.createHTMLDocument ( "
    ")) createElement. ( "
    taban
    ")) href = r.location.href, t.head.appendChild (i)). t = r) o = S .exec (e), a =! n && [], o? [t.createElement (o [1])] :( o = olmak ([e], t, a) bir && a.length && ağırlık (a) .Gergi ( ), w.merge ([], o.childNodes)), w.offset = {setOffset: işlev (e, t, n) {var r, i, o, a, u, s, l, c = w w css (yani, "
    pozisyonu
    "), f = (e), d = {}; "
    statik
    " === c && (e.style.pozisyon = "
    nispi
    "), u = f.offset (), "
    üst
    "), s = w.css (e) "
    sol
    ", o = w.css (e, (I = ( "
    mutlak
    " == = c || "
    sabit
    " === c) && (o + s) .indexOf ( "
    otomatik
    ")?> - 1), (a = (r = f.position ().) ister üst, i = r.left ) :( a = parseFloat (o) || 0, i = parseFloat (ler) || 0), g (t) && (t = t.call (e, n, w.extend ({} u)) bölgesi "
    ile
    "), boş! = t.top && (d.top = t.top-u.top + a), boş! = t.left && (d.left = t.left-u.left + i) t? t.using.call (e, d): f.css (d)}}, w.fn.extend ({offset: function (e) {if (arguments.length) void döndürür 0 === e? this: this.each (işlev (t) {w.offset.setOffset (bu, e, t)}), var t, n, r = bu [0]; eğer (r) r.getClientRects (). ? (t = r.getBoundingClientRect (), n = r.ownerDocument.defaultView {En: t.top + n.pageYOffset sol + n.pageXOffset t.left}): {En: 0,: ​​0} }, position: function () {if (bu [0]) {var e, t, n, r = bu [0], i = {üst: 0, sol: 0}; eğer ("
    Sabit
    "=== w.css (r,"
    konum
    ")) t = r.getBoundingClientRect (); başka {t = this.offset (), n = r.ownerDocument e = r.offsetParent || n.documentElement (e && (e === n.body || e === n.documentElement) && "
    statik
    " === w.css (e, "
    pozisyon
    ")) e = e.parentNode ederken;! e && e == r && 1 === e.nodeType && ((i = w (e) .offset ()). En + = w.css (yani, "
    borderTopWidth
    ",! 0), i.left + = w.css (yani, "
    borderLeftWidth
    " , 0))} dönüş {En:! t.top-i.top-w.css (r, "
    marginTop
    ", 0), sol: t.left-i.left-w.css (r, "
    marginLeft
    ",! 0)}}}, offsetParent: function () {return this.map (function () {var e = this.offsetParent; iken (e &&"
    statik
    "=== w.css (e,"
    position
    ") ) e = e.offsetParent; return e || xe})}}), w.each ({scrollLeft: "
    pageXOffset
    ", scrollTop: "
    pageYOffset
    "}, işlev (e, t) {var n = "
    pageYOffset
    " = == t w.fn [e] = işlev (r) {dönüş _ (bu, işlev (e, r, i) {var o; if (v (e)? o = e: 9 === e.nodeType && (o = e. defaultView), void 0 === i) dönüş o? o [t]: e [r]; o? o.scrollTo (n? o.pageXOffset: i, n? i: o.pageYOffset): e [r] = ı}, e, r, arguments.length)}}), w.each (e, t) {w.cssHooks [t], ze (h.pixelPosition = (fonksiyonu [ "
    üst
    ", "
    sol
    "] işlevi (e, n) {if (n) dönüş n = Fe (e, t), Me.test (n)? w (e) .pozisyon () [t] + "
    px
    ": n})}), w.each ({Yükseklik: "
    yükseklik
    ", En: "
    genişlik
    "}, fonksiyon (örn, t) {w.each ({doldurma "
    iç
    " + e, içeriği: t,: "
    " "
    dış
    " + e }, işlev (n, r) {w.fn [r] = işlev (i, o) {var a = arguments.length && (n || "
    boolean
    "! = typeof i), u = n || (! 0 === i ||! 0 === o? "
    kenar
    boşluğu
    ": "
    kenarlık
    "), geri dönüş _ (bu, işlev (t, n, i) {var o; dönüş v (t)? 0 === r .indexOf ( "
    dış
    ") t [ "
    iç
    " + e]: t.document.documentElement ["
    müşteri
    "+ e]: 9 === t.nodeType (o = t.documentElement, Math.max (t.body ["
    kaydırma
    "+ e] o ["
    kaydırma
    "+ e] t.body ["
    offset
    "+ e", o ["offset" + e], o ["client" + e]
  )
):
void 0 === i ? w.css(t, n, u) : w.style(t, n, i, u)
},
t, a ? i : void 0, a
)
}
})
}),
w.each("odaklama odak"
focusin
focusout
"yeniden boyutlandır" > kaydırma
fareyle
üzerine
geldikten
sonra
fareyle
üzerine
gelindiğinde
fareyi
farzedelim.keyup
contextmenu
".split ("
"), işlev (e, t) {w.fn [t] = işlev (e, n) {return arguments.length> 0? this.on (t, null, e, n) : this.trigger (t)}}), w.fn.extend ({hover: işlev (e, t) {return this.mouseenter (e) .mouseleave (t || e)}}), w.fn. genişlet ({bind: işlev (e, t, n) {return this.on (e, null, t, n)}, aç: işlev (e, t) {return this.off (e, null, t)} temsilci: function (e, t, n, r) {return this.on (t, e, n, r)}, undelegate: function (e, t,n) {return 1 === arguments.length? this.off (e, " ** "): this.off (t, e || " ** ", n)}}), w.proxy = işlev ( e, t) {var n, r, i; eğer ("
string
" == typeof t && (n = e [t], t = e, e = n), g (e)) geri dönüş r = o.call ( argümanlar, 2), i = function () {return e.apply (t || bu, r.concat (o.call (argümanlar))), i.guid = e.guid = e.guid || w. guıd ++ ı}, w.holdReady = fonksiyonu (e) {e w.readyWait ++: (! 0) w.ready} w.isArray = Array.isArray, w.parseJSON = JSON.parse, w.nodeName = D w.isFunction = g, w.isWindow = v, w.camelCase = Q, w.type = b, w.now = Date.now, w.isNumeric = işlev (e) {var t = w.type (e ) (return; "
number
" === t || "
string
" === t) &&! isNaN (e-parseFloat (e))}, "

function

" == typeof tanımlayın && define.amd && define ("
jquery
", [] , function () {return w}), var vt = e.jQuery, yt = e. $; geri dönüş w.noConflict = işlev (t) {return e. $ === w && (e. $ = yt), t && e .jQuery === ağırlık veVe (e.jQuery = vt))} w t || (e.jQuery = e $ = W).} A;
